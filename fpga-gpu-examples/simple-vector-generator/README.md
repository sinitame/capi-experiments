# GPU vector addition from FPGA generator

This simple example illustrates how data can be exchanged bewteen an FPGA and a GPU

## Prerequisites

In order to run this example, you will need the following :

* A Power9 server (tested on AC922)
* Nvidia CUDA Toolkit (nvcc)
* SNAP sources [SNAP official repository](https://github.com/open-power/snap)
* A CAPI2.0 compatible FPGA board already configured to support SNAP (only AD9V3 supported for now)
* [capi-utils](https://github.com/ibm-capi/capi-utils) tools installed 

To run the code, FPGA card needs to be flashed with the action binaries. Binaries files can be found in `src/fpga/images/` and the card can be fashed using capi-utils functions:

* Step 1 : capi-flash-script XX_primary.bin XX_secondary.bin
* Step 2 : go to SNAP sources git directory and run `make software` and `source snap_path.sh` to compile and add snap utils functions to the path.
* Step 3 : run `snap_maint -v` to see if FPGA action is recognised by the HOST (action type should be : 0x1014100e)

Now you are sure that the FPGA is flashed with your action ! 

## Example overview

The aim of this example is to show how to send data from FPGA (here data is generated by FPGA) to HOST memory or to GPU memory using different copy methods :
* With HOST buffering + cudaMemCopy
* With Unified Memory (allocated on the GPU)
* With mmap/mbind method (Not Implemented yet)

Different part of the application can be compiled seperatly by using the top Makefile:

* **make fpga** will compile FPGA related code that can be run with `action_runner` with the following options:
  * Vector sizes (-s)          *will define the size of FPGA buffers : size is limited by FPGA max buffer size (131072 with this image)*
  * Number of iterations (-n)  *will define the number of read/writes performed within a run*
  * Enable verbosity (-v)
  
* **make gpu** will compile GPU related code that can be run with `kernel_runner` with the following options:
  * Vector sizes (-s)         *will define the size of GPU buffers* 
  * Number of iterations (-n) *will define the number of iteration performed within a run*
  * Enable verbosity (-v)
  * Host buffering (-H)       *set config 1, without this option there is no HOST buffering so we are in config 2*
  * Enable fpga emulator (-f) *emulate how FPGA would behave*
  * Waiting time (-w)         *wait delay to emulate different FPGA processing time*

* **make host** will compile main application (with FPGA and GPU parts). Application can be run with `main_application` with the following options:
  * Vector sizes (-s)          *will define the size of all buffers : size is limited by FPGA max buffer size (131072 with this image)*
  * Number of iterations (-n)  *will define the number of iteration performed within a run*
  * Enable verbosity (-v)
  * Host buffering (-H)         *set config 1, without this option there is no HOST buffering so we are in config 2*


